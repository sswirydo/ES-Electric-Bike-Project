---------------------------------------------------------------------
-- Constants:
const
  SHORT_DROP_NUM:int = 2;
  LONG_DROP_NUM:int = 10;
  MAX_NOF_SHORT_DROPS:int = 7;
  MAX_SPEED:real = 7.0;
  BRK_SOFT:real = 1.0;

---------------------------------------------------------------------

-- task L1
node LongDropCounter(x:bool) returns (c:int);
var prev_c:int;
let
  prev_c = 0 -> pre c;
  c = (if x then 0
            else if not x then (prev_c + 1)
            else prev_c);
tel


-- private to the ShortDrop node
-- counts number of 'time' units since UP is false
node ShortCounter(x:bool) returns (c:int);
var prev_c:int;
let
  prev_c = 0 -> pre c;
  c = (if x then 0
            else if not x then (prev_c + 1)
            else prev_c);
tel

node ShortDrop(x:bool) returns (y:bool);
var can_short:bool;
let
  can_short = ShortCounter(x) mod 2 = 0; -- note: second "=" is for equality, not assignement

  -- we check if i and i-1 of UP are false, 
  -- if so, set the shortDrop to true iff we didn't have a short drop before (modulo)
  y = ( if not x and not (true->pre(x)) then can_short 
        else false
  ); 
tel

-- counts the number of ShortDrops encountered during program execution
node ShortDropCounter(x:bool) returns (c:int);
var prev_c:int;
let
  prev_c = 0 -> pre c;
  c = (if ShortDrop(x) then (prev_c + 1)
        else prev_c);
tel

node ConnectionAlarm(up:bool) returns (alarm:bool);
let

  -- Two conditions:
  -- a) The number of “short drops” is ≥ 7. A short drop is a loss of communication (UP is false) lasting ≥ 2 steps.
  -- b) A “long drop” happens. A long drop is an absence of UP lasting ≥ 10 steps

  -- alarm = (if LongDropCounter(up) >= 10 then true
  --           else if ShortCounter(ShortDrop(up)) >= 7 then true
  --           else false;

  alarm = ( if false->pre(alarm) = true then true -- ensures alarm stays ON once set
            else if ShortDropCounter(up) >= 7 then true -- looks for 7 short drops of 2 units
            else if LongDropCounter(up) >= 10 then true -- looks for 1 long drop of 10 units
            else false
  );
tel


-- task L2
node BrakeCableActuator(brk:real; up:bool) returns (clinch:bool);
let
  clinch = false;
tel

-- task L3
node LossyChannel(rnd,brk:real; up:bool) returns (brk_rcvd:real);
let
  brk_rcvd = 0.0;
tel

-- task L4
node MotorController(brk_rcvd:real; up:bool; human,speed,battery:real) returns (asst_lvl:real);
let
  asst_lvl = 0.0;
tel

-- task L5
node System(up:bool; rnd,brk,human,speed,battery:real) returns (clinch:bool; asst_lvl:real);
var
  alarm:bool;
  brk_rcvd:real;
let
  clinch = BrakeCableActuator(brk,up);
  brk_rcvd = LossyChannel(rnd,brk,up);
  asst_lvl = MotorController(brk_rcvd,up,human,speed,battery);
  alarm = ConnectionAlarm(up);
tel

