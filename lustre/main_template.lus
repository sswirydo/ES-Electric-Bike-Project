---------------------------------------------------------------------
-- Constants:
const
  SHORT_DROP_NUM:int = 2;
  LONG_DROP_NUM:int = 10;
  MAX_NOF_SHORT_DROPS:int = 7;
  MAX_SPEED:real = 7.0;
  BRK_SOFT:real = 1.0;

---------------------------------------------------------------------

-- task L1
node LongDropCounter(x:bool) returns (c:int);
var prev_c:int;
let
  prev_c = 0 -> pre c;
  c = (if x then 0
            else if not x then (prev_c + 1)
            else prev_c);
tel

-- private to the ShortDrop node
-- counts number of 'time' units since UP is false
node ShortCounter(x:bool) returns (c:int);
var prev_c:int;
let
  prev_c = 0 -> pre c;
  c = (if x then 0
            else if not x then (prev_c + 1)
            else prev_c);
tel

node ShortDrop(x:bool) returns (y:bool);
var can_short:bool;
let
  can_short = ShortCounter(x) mod SHORT_DROP_NUM = 0; -- note: second "=" is for equality, not assignement
  -- we check if i and i-1 of UP are false, 
  -- if so, set the shortDrop to true iff we didn't have a short drop before (modulo)
  y = ( if not x and not (true->pre(x)) then can_short 
        else false
  ); 
tel

-- counts the number of ShortDrops encountered during program execution
node ShortDropCounter(x:bool) returns (c:int);
var prev_c:int;
let
  prev_c = 0 -> pre c;
  c = (if ShortDrop(x) then (prev_c + 1)
        else prev_c);
tel

node ConnectionAlarm(up:bool) returns (alarm:bool);
let
  alarm = ( if false->pre(alarm) = true then true -- ensures alarm stays ON once set
            else if ShortDropCounter(up) >= MAX_NOF_SHORT_DROPS then true -- looks for 7 short drops of 2 units
            else if LongDropCounter(up) >= LONG_DROP_NUM then true -- looks for 1 long drop of 10 units
            else false
  );
tel

-- task L2
node BrakeCableActuator(brk:real; up:bool) returns (clinch:bool);
let
  -- brk = 0 --> NO BREAK
  -- brk in (0; BRK_SOFT] --> SOFT BREAK
  -- brk >BRK_SOFT --> HARD BREAK
  clinch = (  if ConnectionAlarm(up) and (brk <= BRK_SOFT and brk > real(0.0)) then true -- SOFT BREAK + ALARM
              else if brk > BRK_SOFT then true -- HARD BREAK
              else false
  );
tel

-- task L3
node LossyChannel(noise,brk:real; up:bool) returns (brk_rcvd:real);
let
  bck_rcvd = (if up then brk else noise);
tel

-- task L4
node MotorController(brk_rcvd:real; up:bool; human,speed,battery:real) returns (asst_lvl:real);
var 
  assist_allowed:bool;
  regen_allowed:bool;
let
  assist_allowed = (if (ConnectionAlarm(up) then false
                    else if speed > MAX_SPEED then false
                    else if battery = 0.0 then false
                    else true
  );
  regen_allowed = ( if (ConnectionAlarm(up) then false
                    else if not up then false
                    else true
  );
  asst_lvl = (  if regen_allowed then -brk_rcvd
                else if assist_allowed then human
                else 0.0
  );
tel

-- task L5
node System(up:bool; noise,brk,human,speed,battery:real) returns (clinch:bool; asst_lvl:real);
var
  alarm:bool;
  brk_rcvd:real;
let
  clinch = BrakeCableActuator(brk,up);
  brk_rcvd = LossyChannel(noise,brk,up);
  asst_lvl = MotorController(brk_rcvd,up,human,speed,battery);
  alarm = ConnectionAlarm(up);

  clinch = (if alarm and (brk_rcvd > 0.0) then true
            else clinch
  );

  asst_lvl = (  if alarm and asst_lvl < 0.0 then 0.0
                else asst_lvl
  );

  asst_lvl = (  if asst_lvl < 0.0 and brk <= 0.0 then 0.0
                else asst_lvl
  );

  asst_lvl = (  if speed > MAX_SPEED and asst_lvl > 0.0 then 0.0
                else asst_lvl
  );

  asst_lvl = (  if (asst_lvl = 0.0) or (asst_lvl = -brk) or (asst_lvl = human) then asst_lvl
                else asst_lvl = 0.0
  );

  -- ! todo
  -- if the braking and assisting are both requested at the same time and the connection
  --is up and there is no alarm, then the motor should engage the regenerative braking

tel

